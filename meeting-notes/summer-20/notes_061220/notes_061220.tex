\documentclass{article}

\newcommand{\ep}{\rule{.06in}{.1in}}
\textheight 9.5in

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphicx, subcaption, booktabs}
\graphicspath{{/Users/andrewwork/thesis/jump-velocity/plots/}}

\usepackage{tikz, pgfplots, pgfplotstable, chemfig}

% \usepgfplotslibrary{colorbrewer, statistics}
% \pgfplotsset{
%   exact axis/.style={grid=major, minor tick num=4, xlabel=$v^*$,
%     legend entries={PDF, CDF},},
%   every axis plot post/.append style={thick},
%   table/search
%   path={/Users/andrewwork/thesis/jump-velocity/dat-files},
%   colormap/YlGnBu,
%   cycle list/Set1-5,
%   legend style={legend cell align=left,},
% }

% \usepgfplotslibrary{external}
% \tikzexternalize

\renewcommand{\arraystretch}{1.2}
\pagestyle{empty} 
\oddsidemargin -0.25in
\evensidemargin -0.25in 
\topmargin -0.75in 
\parindent 0pt
\parskip 12pt
\textwidth 7in
%\font\cj=msbm10 at 12pt

\newcommand{\tn}{\textnormal}
\newcommand{\stiff}{\frac{k_f}{\gamma}}
\newcommand{\dd}{d}
\newcommand{\Der}[2]{\frac{\dd #1}{\dd #2}}
\newcommand{\Pder}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\Integral}[4]{\int_{#3}^{#4} {#1} \dd #2}
\DeclareMathOperator{\Exp}{Exp}

% Text width is 7 inches

\def\R{\mathbb{R}}
\def\N{\mathbb{N}}
\def\C{\mathbb{C}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\def\H{\mathbb{H}}
\def\B{\mathcal{B}} 
%\topmargin -.5in 

\setcounter{secnumdepth}{2}
\begin{document}
\pagestyle{plain}

\begin{center}
  {\Large Meeting Notes (\today)}
\end{center}

\large{\textbf{Optimizing Regularized Stokeslets}}

\textbf{Exploiting symmetry}
\begin{itemize}
\item Recap: Want to speed up the generation of the quadrature matrix,
  which comes from discretizing the integral equation
  $\mathbf{u}(\mathbf{x}) = \int \underline{\underline{S}}(\mathbf{x},
  \mathbf{x}_0) \mathbf{f}(\mathbf{x}_0) d\mathbf{x}_0$
\item Observation: there is symmetry in the Stokeslet; in
  particular $\underline{\underline{S}}(\mathbf{x}, \mathbf{x}_0) =
  \underline{\underline{S}}^T(\mathbf{x}_0, \mathbf{x})$. After a lot
  of trial and error, I was able to figure out an implementation that
  cuts the compute time in half.
\item I've exploited symmetry to reduce the number of operations and
  memory required to compute the Stokeslet. We can also use the
  Stokeslet's symmetry in solving for the unknown forces.
\item Reminder: the unknown stokeslet strengths $\mathbf{f}$ are found
  by solving the linear system $\hat{\mathbf{u}} =
  \underline{\underline{A}} \hat{\mathbf{f}}$ (hatted vectors contain
  the vector quantities $\mathbf{u}$ and $\mathbf{f}$ evaluated at
  each stokeslet point, and are $\in \R^{3N}$)
\item $\underline{\underline{A}}$ is the quadrature matrix, which is
  not symmetric itself, but due to the symmetry of the Stokeslet, can
  be written as a product of a diagonal matrix of the quadrature
  weights and a symmetric (and apparently spd) matrix
  $\hat{S} \in \R^{3N \times 3N}$
\item So we can use Cholesky factorization to solve the system
  $\hat{\mathbf{u}} = \hat{S} \hat{\mathbf{f}}$, and then divide to
  solve the diagonal system. In order to solve the SPD system, I still
  need to allocate a full matrix, but only need to write to the upper
  triangular elements.
\item I also went through the stokeslets code line by line to make
  sure I wasn't unnecessarily repeating any expensive calculations (in
  particular, I only compute the helper functions shown below once)
\item Using a convergence analysis as a test case, all of these
  changes resulted in a 2.4x speedup relative to the original code.
\end{itemize}

\textbf{Precompute helper functions}
\begin{itemize}
\item The other experiment I wanted to try was precomputing the helper
  functions $H_1$, $H_1'$, $H_2$, $H_2'$, $D_1$, and $D_2$.
\item Reminder: The expression for finding the fluid velocity at a
  point $\mathbf{x}_e$ generated by $M$ reg. Stokeslets located at
  points $\mathbf{x}_{0, k}$ is the following:

  \fbox{\includegraphics[width=\textwidth]{rs_eqns}}
\item I tried a couple of different strategies for precomputing:
  \begin{enumerate}
  \item Linear interpolation (hardly any improvement) vs look-up table
    (way faster)
  \item Precomputing the square root term ($\sqrt{r^2 + \epsilon^2}$)
    only vs. precomputing all of the helper functions individually
  \end{enumerate}
\item The fastest option was precomputing all 6 helper functions, and
  using a lookup table
\item Then I implemented this in the stokeslets code, and ran the same
  convergence analysis above:
  \begin{itemize}
  \item Without precomputing, 24.5 seconds out of 394s total was spent
    computing the helper functions
  \item With precomputing, the look-up time was approx. 1 second out
    of 347s total (computing the free-space Stokeslet and higher-order
    singularities was faster too by a couple of seconds)
  \item Precomputing gave a 20\% speedup in computing the wall-bounded
    Stokeslet in this test case
  \end{itemize}
\item Is this enough of a speedup to justify precomputing? I'm not
  sure. Right now my implementation of the look-up is fairly dumb: I
  compute the helper functions at a uniform spacing in $r$, and throw
  an error if I try to evaluate at an $r$-value outside of the
  precomputed range.
\end{itemize}

\textbf{Equations of motion for the platelet}
\begin{itemize}
\item I've also derived the equations of motion for the platelet, but
  haven't yet written a routine to integrate these to simulate the
  platelet moving in the fluid
\item The translational and angular velocity of the platelet can be
  found using the resistance matrices, given a body force and torque
  acting on the platelet.
\item The differential equations for the platelet's position are easy:
  $\frac{dx_i}{dt} = v_i$.
\item The differential equations for the two orientation angles are:
  \begin{align*}
    \frac{d\phi}{dt} &= \omega_3 \cos(\theta) - \omega_2 \sin(\theta)
    \\
    \frac{d\theta}{dt} &= \omega_1 + \omega_3
                         \frac{\cot(\phi)}{\sin(\theta)}
                         (\cos^2(\theta) - 1) - \omega_2 \cos(\theta)
                         \cot(\phi) 
  \end{align*}
\item I'm pretty confident these are correct: they are the same
  equations that appear in Hammer \& Apte's 1st AD paper
  \cite{Hammer1992}
\item We can test the accuracy with a sphere, comparing a simulation
  with the RS code to a simulation with the asymptotic functions that
  are known for a sphere
\item Open questions: 
  \begin{itemize}
  \item Is the RS code fast enough currently? It takes about 4.5
    minutes (on a single core) to compute the resistance matrix with a
    mesh size of 3,400 nodes, which gives a relative error around 1\%
    in most cases.
  \item With parallelizing, this can be sped up at least a couple of
    times
  \end{itemize}
\end{itemize}

\bibliographystyle{plain}
\bibliography{/Users/andrewwork/Documents/grad-school/thesis/library}

\end{document}




