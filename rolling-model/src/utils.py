# Base functions for rolling models

import numpy as np
from scipy.sparse import block_diag, diags
from scipy.sparse.linalg import spsolve
from scipy.integrate import trapz


def length(z, th, d=0):
    """
    Compute the distance between z and theta

    Parameters
    ----------
    z, th : array_like
        Coordinate arrays specifying points on the wall and the platelet,
        respectively.
    d : scalar
        The minimum separation distance between the platelet and wall.

    Returns
    -------
    array_like
        Returns the distance(s) between z and theta. If z and theta are
        both scalars, then a scalar is returned. Otherwise an array is
        returned.

    Raises
    ------
    ValueError
        If z and th cannot be broadcast to a single shape.
    """
    return np.sqrt((1 - np.cos(th) + d)**2 + (np.sin(th) - z)**2)


def construct_system(M, N, eta, z_vec, th_vec, delta, nu, kap, d_prime=0,
                     saturation=True, scheme='up'):
    if scheme == 'up':
        # Construct A matrix (upwind in theta)
        diagonals = [-np.ones((2*M+1)*(N+1)), np.ones((2*M+1)*N)]
        offsets = [0, 2*M+1]
        A = diags(diagonals, offsets)

        # Construct B matrix (upwind in z)
        subdiag = np.ones((2*M+1)*(N+1) - 1)
        subdiag[(2*M)::(2*M+1)] = 0
        diagonals = [-np.ones((2*M+1)*(N+1)), subdiag]
        offsets = [0, 1]
        B = diags(diagonals, offsets)
    elif scheme == 'bw':
        # Construct A matrix (2nd order upwind in theta)
        main_diag = np.hstack([-3*np.ones((2*M+1)*N)/2, -np.ones(2*M+1)])
        diagonals = [main_diag, 2*np.ones((2*M+1)*N),
                     -np.ones((2*M+1)*(N-1))/2]
        offsets = [0, 2*M+1, 2*(2*M+1)]
        A = diags(diagonals, offsets)
        print(A.shape)

        # Construct B matrix (2nd order upwind in z)
        main_diag = np.hstack([-3*np.ones(2*M)/2, -1])
        main_diag = np.tile(main_diag, reps=N+1)
        supdiag = 2*np.ones((2*M+1)*(N+1) - 1)
        supdiag[(2*M)::(2*M+1)] = 0
        supsupdiag = -np.ones((2*M+1)*(N+1))/2
        supsupdiag[(2*M)::(2*M+1)] = 0
        supsupdiag[(2*M-1)::(2*M+1)] = 0
        diagonals = [main_diag, supdiag, supsupdiag]
        offsets = [0, 1, 2]
        B = diags(diagonals, offsets)
        print(B.shape)

    # Construct C matrix (bond formation term)
    if saturation:
        left_matrix = diags(np.exp(-eta*length(z_vec, th_vec, d_prime)/2))
        right_matrix = block_diag((-np.ones((2*M+1, 2*M+1)),)*(N+1))
        C = np.dot(left_matrix, right_matrix)
    else:
        C = diags(np.exp(-eta*length(z_vec, th_vec, d_prime)/2))

    # Construct D matrix (bond breaking term)
    D = diags(-np.exp(delta*length(z_vec, th_vec, d_prime)))

    # Construct RHS
    R = nu*kap*np.exp(-eta*length(z_vec, th_vec, d_prime)**2/2)

    return A, B, C, D, R


def nd_torque(m_mesh, z_mesh, th_mesh, d=0):
    """
    Calculate the nondimensional torque

    Parameters
    ----------
    m_mesh, z_mesh, th_mesh : array_like
        Arrays specifying the bond distribution, z coordinate mesh, and
        theta coordinate mesh, respectively
    d : scalar, optional
        Minimimum separation distance between the platelet and wall.
        Default value is 0.

    Returns
    -------
    scalar or ndarray
        Total torque generated by the distribution of bonds m_mesh
    """
    tau = trapz(trapz(((1 - np.cos(th_mesh) + d)*np.sin(th_mesh) +
                       (np.sin(th_mesh) - z_mesh)*np.cos(th_mesh))*m_mesh,
                      x=z_mesh, axis=0), x=th_mesh[0, ])
    return tau


def nd_force(m_mesh, z_mesh, th_mesh):
    """
    Calculate the nondimensional force

    Parameters
    ----------
    m_mesh, z_mesh, th_mesh : array_like
        Arrays specifying the bond distribution, z coordinate mesh, and
        theta coordinate mesh, respectively

    Returns
    -------
    scalar or ndarray
        Total force generated by the distribution of bonds m_mesh
    """
    f_prime = trapz(trapz((z_mesh - np.sin(th_mesh))*m_mesh, x=z_mesh, axis=0),
                    x=th_mesh[0, ])
    return f_prime


def find_torque_roll(A, B, C, D, R, om, v, lam, nu, h, kap, M, z_mesh, th_mesh,
                     d_prime=0):
    # Calculate the bond density function
    m = spsolve(om*A + v*lam*B + h*nu*kap*C + nu*D, -R)
    m_mesh = m.reshape(2*M+1, -1, order='F')
    return nd_torque(m_mesh, z_mesh, th_mesh, d_prime), m_mesh


def find_force_roll(A, B, C, D, R, om, v, lam, nu, h, kap, M, z_mesh, th_mesh,
                    d_prime=0):
    # Calculate the bond density function
    m = spsolve(om*A + v*lam*B + h*nu*kap*C + nu*D, -R)
    m_mesh = m.reshape(2*M+1, -1, order='F')
    return nd_force(m_mesh, z_mesh, th_mesh), m_mesh


def find_forces(A, B, C, D, R, om, v, lam, nu, h, kap, M, z_mesh, th_mesh,
                d_prime=0):
    # Calculate the bond density function
    m = spsolve(om*A + v*lam*B + h*nu*kap*C + nu*D, -R)
    m_mesh = m.reshape(2*M+1, -1, order='F')
    return nd_torque(m_mesh, z_mesh, th_mesh, d_prime), \
        nd_force(m_mesh, z_mesh, th_mesh), m_mesh
