%% =====================================================================
%% WARNING: Do NOT edit this file.  It was produced automatically by
%% Nelson H. F. Beebe <beebe@sunfall.math.utah.edu>
%% from file://sunfall.math.utah.edu/u/sy/beebe/tex/bst/xbtxbst.doc 
%% on Fri Apr 14 15:28:23 MDT 2017.
%% =====================================================================
%%%=====================================================================
%%% @BibTeX-style-file{
%%%     author          = "Nelson H. F. Beebe",
%%%     version         = "3.00",
%%%     date            = "10 April 2017",
%%%     time            = "08:38:45 MDT",
%%%     filename        = "x-plain.bst",
%%%     address         = "Department of Mathematics
%%%                        University of Utah
%%%                        Salt Lake City, UT 84112
%%%                        USA",
%%%     telephone       = "+1 801 581 5254",
%%%     FAX             = "+1 801 581 4148",
%%%     URL             = "http://www.math.utah.edu/~beebe",
%%%     checksum        = "51976 2649 9321 70400",
%%%     email           = "beebe@math.utah.edu (Internet)",
%%%     codetable       = "ISO/ASCII",
%%%     keywords        = "bibliography style; BibTeX",
%%%     license         = "public domain",
%%%     supported       = "yes",
%%%     docstring       = "This file is a modification of the standard
%%%                        BibTeX btxbst.doc file, or is a .bst file
%%%                        derived from that modification.  It contains
%%%                        optional added support for CODEN, ISBN, ISSN,
%%%                        LCCN, and PRICE fields, extended PAGES
%%%                        fields, the PERIODICAL entry, and extended
%%%                        citation label suffixing.
%%%
%%%                        Preprocessing this file with a suitable
%%%                        C preprocessor can extract extensions of
%%%                        the original four sample BibTeX files:
%%%
%%%                            x-abbrv.bst x-alpha.bst x-plain.bst x-unsrt.bst
%%%
%%%                        An important new feature, borrowed from the
%%%                        author's xchicago.bst, is that all but two
%%%                        instances of empty$ are replaced by
%%%                        empty.or.unknown, a new function that
%%%                        treats a value containing only white space,
%%%                        or beginning with two question marks, as if
%%%                        it were empty, and thus, must disappear from
%%%                        the output .bbl file.  Experience with
%%%                        formatting over a million bibliography
%%%                        entries shows the strong need for marking
%%%                        missing (but still needing to be found)
%%%                        values, to distinguish from values that are
%%%                        simply not set.
%%%
%%%                        In addition, date formatting supports a day
%%%                        keyword, so that bibliography entries can be
%%%                        written with
%%%
%%%                            day   = {23},
%%%                            month = aug,
%%%
%%%                        instead of the language-dependent awkward
%%%                        forms required by the standard styles
%%%
%%%                            month = {23~} # aug,
%%%                            month = aug # {~23},
%%%
%%%                        These older forms are, of course, still
%%%                        handled correctly.
%%%
%%%                        The UNIX C preprocessor can be used to
%%%                        extract the standard styles, as follows:
%%%
%%%                            cpp -P -DPLAIN xbtxbst.doc >plain.bst
%%%                            cpp -P -DUNSRT xbtxbst.doc >unsrt.bst
%%%                            cpp -P -DALPHA xbtxbst.doc >alpha.bst
%%%                            cpp -P -DABBRV xbtxbst.doc >abbrv.bst
%%%
%%%                        To obtain correct file header checksums, pipe
%%%                        the output through the checksum program, e.g.
%%%
%%%                            cpp -P -DPLAIN xbtxbst.doc | checksum >plain.bst
%%%
%%%                        The accompanying UNIX Makefile automates this
%%%                        job, and provides some extra leading comments
%%%                        in the generated style files warning the user
%%%                        not to modify them.
%%%
%%%                        Additional optional definitions are recognized
%%%                        to provide extensions to the standard styles:
%%%
%%%                            -D_CODEN for CODEN output
%%%
%%%                            -D_ISBN for ISBN output
%%%
%%%                            -D_ISSN for ISSN output
%%%
%%%                            -D_LCCN for LCCN output
%%%
%%%                            -D_PRICE for price output,
%%%
%%%                            -D_BOOKPAGES for book, techreport, manual,
%%%                            and thesis pages output.
%%%
%%%                            -D_URL to get World-Wide Web Uniform
%%%                            Resource Locator (URL) output.
%%%
%%%                            -D_NUMERIC_SUFFIXES to get numeric
%%%                            label suffixes -1, -2, ..., -26, instead of
%%%                            letters a, b, ..., z, so as to correctly
%%%                            handle alpha-style bibliographies with more
%%%                            than 26 entries for a single author in one
%%%                            year.  Change letter suffix code to switch
%%%                            to numeric suffixes if more than 26 letters
%%%                            are used, so that no matter which scheme is
%%%                            selected, correct output will always be
%%%                            obtained.
%%%
%%%                        The CODEN, ISBN, ISSN, LCCN, PRICE, and URL
%%%                        values are wrapped inside macros \showCODEN{}
%%%                        etc. that the user can provide alternate
%%%                        definitions of to change the formatting, or
%%%                        to suppress their output altogether.  That
%%%                        way, output identical to that of the four
%%%                        standard BibTeX style files can be obtained
%%%                        with these extended files, if these macros
%%%                        are defined to expand to empty strings.
%%%
%%%                        URL handling is slightly more complex,
%%%                        because URLs can contain characters which TeX
%%%                        must handle in verbatim mode in a typewriter
%%%                        font, and such text cannot readily appear
%%%                        inside nested macro arguments.  Consequently,
%%%                        URLs are formatted in the .bbl file like
%%%                        this:
%%%                            \ifshowURL {\showURL \url|...|} \fi
%%%                        where \showURL takes no argument, and
%%%                        normally expands to the 4-character string
%%%                        URL<space>.  The grouping braces ensure that
%%%                        any font changes made by \showURL remain
%%%                        localized.  Vertical bar is chosen as the
%%%                        verbatim path delimiter, because it cannot
%%%                        appear in URLs.  The other prohibited ISO
%%%                        Latin 1 characters are the non-printing
%%%                        control characters 0..31, plus those in the
%%%                        range 128..255, plus the ten special
%%%                        characters
%%%
%%%                            { } [ ] \ ^ ~ < > `
%%%
%%%                        See Internet RFC 1630 (June 1994) for more
%%%                        details.  (Backquote is not even mentioned
%%%                        there.)
%%%
%%%                        As an example of font changes, in LaTeX 2e
%%%                        you might define
%%%                            \newcommand{\showURL}{URL
%%%                                \let \oldtt = \tt
%%%                                \renewcommand{\tt}{\oldtt \itshape}}
%%%                        to get URLs set in a typewriter italic font.
%%%
%%%                        If desired, a sed script can be used to
%%%                        eliminate non-essential comments (this
%%%                        reduces the file size by 2/3); a command
%%%                        filter step like
%%%                                sed -e '/^%$/d' -e '/^%[^%].*$/d'
%%%                        will accomplish that job.
%%%
%%%                        The checksum field above contains a CRC-16
%%%                        checksum as the first value, followed by the
%%%                        equivalent of the standard UNIX wc (word
%%%                        count) utility output of lines, words, and
%%%                        characters.  This is produced by Robert
%%%                        Solovay's checksum utility."
%%%     }
%%% ====================================================================
%%% Revision history (reverse time order):
%%%
%%% 3.00 [10-Apr-2017]
%%%      Major extension for the new x-*.bst family, with support of
%%%      DOI data, and user control of the typesetting of all output
%%%      fields, WITHOUT having to regenerate the .bbl file, or worse,
%%%      modify the .bib file.  Because the .bbl file makes extensive
%%%      use of conditional and formatting wrappers, it is essential
%%%      to have a \usepackage{x-bst} command in the LaTeX file
%%%      preemable, or \input{x-bst.tex} in a plain TeX file.
%%%
%%% 2.04 [20-Dec-1999]
%%%      Correct error in handling of missing data in format.date.
%%%
%%% 2.03 [15-May-1996]
%%%      Add CODEN support, ISBN and ISSN output for Article entries,
%%%      and ISBN output for TechReport entries (yes, these sometimes
%%%      do have ISBNs).
%%%
%%%      Add wrapper macros \showXYZ{} (XYZ = CODEN, ISBN, ISSN, LCCN,
%%%      PRICE, and URL) defined inside the thebibliography environment
%%%      to expand to XYZ (except for PRICE) and their arguments,
%%%      PROVIDED they are not already defined.  That way, the user can
%%%      provide alternate definitions outside the thebibliography
%%%      environment, for example, to suppress particular ones, or
%%%      to alter the font used.
%%%
%%%      Substantially revise leading comments to better document the
%%%      extensions.
%%%
%%% 2.02 [01-Apr-1996]
%%%	 Add day keyword support with new code in format.date function.
%%%	 Oren Patashnik will include this new keyword in standard styles
%%%	 in BibTeX 1.0.
%%%
%%%	 Add new function collapse.pagerange, and use it to collapse
%%%	 page ranges with identical initial and final numbers to a
%%%	 single number, so that bibliography files can distinguish
%%%	 between one-page documents, and documents missing final page
%%%	 numbers.
%%%
%%% 2.01 [25-Oct-1994]
%%%	 Add URL output support.
%%%
%%% 2.00 [12-Oct-1994]
%%%	 Add support for pages in theses and manuals, treating them
%%%	 like Book and InBook pages.
%%%
%%%	 Correct ISSN support: a typo caused output of ISBN instead of
%%%	 ISSN.
%%%
%%%	 Wherever ISBNs are output, also output an ISSN, if one
%%%	 exists, and vice versa.  The reason is that some periodicals
%%%	 (e.g. The X Resource, published by O'Reilly and Associates)
%%%	 have both ISSN and ISBN numbers, and can be purchased either
%%%	 as journal subscriptions, or as single volumes.
%%%
%%%	 For InProceedings and Proceedings output, issue a warning for
%%%	 a missing publisher: even though that field is optional, a
%%%	 bibliographic reference without it is incomplete.
%%%
%%%	 Remove harmless, but unneeded, single horizontal space before
%%%	 price output added with version 1.03.
%%%
%%%	 Change Proceedings and InProceedings to treat address values
%%%	 as publisher addresses, as they are with every other document
%%%	 type, rather than as conference addresses, which belong in
%%%	 the title field (that is how major libraries, including OCLC
%%%	 and Library of Congress, with nearly 60M holdings, represent
%%%	 them).  The need for this change has been discussed with
%%%	 BibTeX's author, Oren Patashnik, and there is a good
%%%	 possibility that BibTeX 1.0 will contain the change
%%%	 implemented here.  This is an INCOMPATIBLE change that will
%%%	 produce different .bbl file formatting.  However, the TUG and
%%%	 BibNet Project bibliography projects have consistently used
%%%	 address to mean publisher/organization/institution address, and so
%%%	 already conform to the new practice.
%%%
%%% 1.05 [30-May-1994]
%%%	 Add NUMERIC_SUFFIXES support.
%%%
%%%	 Change all preprocessor statements to put else and endif
%%%	 labels inside C-style comments to conform to 1989 ISO/ANSI C
%%%	 Standard.
%%%
%%% 1.04 [11-Nov-1993]
%%%	 Add underscore prefix to new processor symbols to prevent
%%%	 substitution in comments
%%%
%%% 1.03 [11-Oct-1993]
%%%	 Add support for LCCN (Library of Congress Catalog Number)
%%%	 and price fields, and make ISBN, ISSN, LCCN, and price
%%%	 selectable by preprocessor conditionals.
%%%
%%% 1.02 [12-Sep-1991]
%%%      Merge in Barbara N. Beeton's suggestion for hyphen-less
%%%      line breaks around volume(number):page.
%%%
%%% 1.01 [10-Sep-1991]
%%%      Update file comment header and use Solovay checksum program.
%%%
%%% 1.00 [17-Oct-1990]
%%%      Original version merging hand-edits of is-xxx.bst files into
%%%      this master file, xbtxbst.doc.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% BibTeX `plain' family
%%       version 0.99b for BibTeX versions 0.99a or later, LaTeX version 2.09.
%%       Copyright (C) 1985, all rights reserved.
%%       Copying of this file is authorized only if either
%%       (1) you make absolutely no changes to your copy, including name, or
%%       (2) if you do make changes, you name it something other than
%%       btxbst.doc, plain.bst, unsrt.bst, alpha.bst, and abbrv.bst.
%%       This restriction helps ensure that all standard styles are identical.
%%       The file btxbst.doc has the documentation for this style.



















ENTRY
  { address
    articleno
    author

    bookpages

    booktitle
    chapter

    coden

    day

    DOI

    edition
    editor
    howpublished
    institution

    isbn
    isbn-13


    issn


    issn-l

    journal
    key

    lccn

    month
    note
    number
    organization
    pages
    pagecount

    price

    publisher
    school
    series
    title
    type

    URL

    volume
    year
  }
  {}

  { label }



INTEGERS { output.state before.all mid.sentence after.sentence after.block }

FUNCTION {init.state.consts}
{
  %% Initialize output.state enumeration constants.
  %%
  %% At entry: stack = ... top:[top-string]
  %% At exit:  stack = ... top:[top-string]
  %%
  %% Global variables set: before.all, mid.sentence, after.sentence, after.block

  #0 'before.all :=
  #1 'mid.sentence :=
  #2 'after.sentence :=
  #3 'after.block :=
}


STRINGS { b e new.pages original.t s t }

FUNCTION {empty.or.unknown}
{
  %% Examine the top stack entry, and push 1 if it is empty, or
  %% consists only of whitespace, or is a string beginning with two
  %% queries (??), and otherwise, push 0.
  %%
  %% This function provides a replacement for empty.or.unknown, with the
  %% convenient feature that unknown values marked by two leading
  %% queries are treated the same as missing values, and thus, do not
  %% appear in the output .bbl file, and yet, their presence in .bib
  %% file(s) serves to mark values which are temporarily missing, but
  %% are expected to be filled in eventually once more data is
  %% obtained.  The TeX User Group and BibNet Project bibliography
  %% archives make extensive use of this practice.
  %%
  %% An empty string cannot serve the same purpose, because just as in
  %% statistics data processing, an unknown value is not the same as an
  %% empty value.
  %%
  %% At entry: stack = ... top:[string]
  %% At exit:  stack = ... top:[0 or 1]

  duplicate$ empty$
    { pop$ #1 }
    { #1 #2 substring$ "??" = }
  if$
}

FUNCTION {output.nonnull}
{
  %% Write stack[top-1] to the output file, with any needed
  %% following punctuation (determined by the value of output.state),
  %% and possibly, a newline and \newblock command, and remove it from
  %% the stack.  Then set stack[top-1] = stack[top] and top = top - 1.
  %%
  %% At entry: stack = ... top-2:[top-2 string] top-1:[string] top:[string]
  %% At exit:  stack = ... top-1:[top-2 string] top:[string],
  %% and [top-1 string] has been written out, possibly with trailing
  %% punctuation determined by the value of output.state.
  %%
  %% Global variables set: output.state, s
  %%
  %% Logic in C-like pseudocode:
  %%
  %%	s = stack[top]
  %%	switch (output.state)
  %%	{
  %%	case mid.sentence:	printf(stack[top-1], ", ");					     break;
  %%	case after.block:	printf(stack[top-1], ".\n\\newblock "); output.state = mid.sentence; break;
  %%	case before.all:	printf(stack[top-1]);                   output.state = mid.sentence; break;
  %%	// output.state should now be after.block
  %%	default:		printf(stack[top-1], ". "); 		output.state = mid.sentence; break;
  %%	}
  %%	stack[--top] = s

  's :=
%%:   newline$ "DEBUG 1: output.nonnull: s = [" s * "]" * write$ newline$
%%:   duplicate$ 't :=
%%:   "DEBUG 2: output.nonnull: t = [" t * "]" * write$ newline$
%%:   "DEBUG 3: output.nonnull: output.state = " output.state int.to.str$ * write$ newline$
  output.state mid.sentence =
    { ", " * write$ }
    { output.state after.block =
        { add.period$ write$
          newline$
          "\newblock " write$
        }
        { output.state before.all =
            'write$
            { add.period$ " " * write$ }
          if$
        }
      if$
      mid.sentence 'output.state :=
    }
  if$
  s
}

FUNCTION {output}
{
  %% If the string at top-of-stack is empty or unknown, discard it.
  %% Otherwise, output the string at stack position top-1, followed by
  %% any needed punctuation, and remove it from the stack, leaving the
  %% initial top-of-stack unchanged on exit, except that the stack
  %% pointer has reduced by 1.
  %%
  %% Usage:
  %% 	field-value output
  %%
  %% At entry: stack = ... top-1:[string] top:[top-string]
  %% At exit:  stack = ... top:[top-string]

  duplicate$ empty.or.unknown
    'pop$
    'output.nonnull
  if$
}

FUNCTION {output.check}
{
  %% Output a string, issuing a warning if it is empty or unknown.
  %%
  %% Usage:
  %% 	field-value "field-name" output.check
  %%
  %% Because string output is delayed so that proper end-of-sentence
  %% or end-of-block punctuation can be supplied, it is actually the
  %% PREVIOUS stacked string, at stack slot top-2, that is output. The
  %% new string takes its place, with the stack top reduced by 2.
  %%
  %% At entry: stack = ... top-2:[some-string] top-1:[string-value] top:[string-name]
  %% At exit:  stack = ... top:[string-value]
  %%
  %% Global variables set: t

  't :=
  duplicate$ empty.or.unknown
    { pop$ "empty or unknown " t * " in " * cite$ * warning$ }
    'output.nonnull
  if$
}

FUNCTION {required.check}
{
  %% Check that a required value is present, and if not, issue a warning.
  %% There is no output or other effect on global state, and the top two
  %% stack entries are discarded on return.
  %%
  %% Usage:
  %%     field-value "name-of-field" required.check
  %%
  %% At entry: stack = ... top-2:[some-string] top-1:[field-value] top:[field-name]
  %% At exit:  stack = ... top:[some-string]
  %%
  %% Global variables set: t

  't :=
  empty.or.unknown
    { "missing required " t * " in " * cite$ * warning$ }
    { }
  if$
}

FUNCTION {wrap}
{
  %% Wrap a value in a TeX macro, replacing the top two stack entries
  %% with the wrapped value.  If the value is empty or unknown, the
  %% stack result is an empty string.
  %%
  %% Usage:
  %%     field-value field-name wrap
  %%
  %% Example:
  %%     journal "journal" wrap -> "\showJOURNAL{journal}"
  %%
  %% At entry: stack = ... [top-1]:  value   [top]: "name"
  %% At exit:  stack = ... [newtop]: "\showNAME{value}"
  %% Global variables set: s t

  't :=

  duplicate$ empty$
    { pop$ "" }
    { }
  if$
  's :=

  s empty.or.unknown
    { "" }
    { "\show" t "u" change.case$ * "{" * s * "}" * }
  if$
}

FUNCTION {wrap.required}
{
  %% Wrap a value in a TeX macro, replacing the top two stack entries
  %% with the wrapped value, and warning if the value is empty or
  %% omitted.
  %%
  %% Usage:
  %%     field-value field-name wrap.required
  %%
  %% Example:
  %%     journal "journal" wrap -> "\showJOURNAL{journal}"
  %%
  %% At entry: stack = ... [top-1]:  value   [top]: "name"
  %% At exit:  stack = ... [newtop]: "\showNAME{value}"
  %%
  %% Global variables set: s t

  't :=
  's :=
  s t required.check
  % "\show" t "u" change.case$ * "{" * s * "}" *
  s t wrap
}

FUNCTION {output.bibitem}
{
  %% Begin the output of a bibliography item, producing
  %%
  %% At entry: stack = empty
  %% At exit:  stack = top(==1):[\bibitem[...]{...}...]
  %%
  %% Global variables set: output.state

  newline$

  "\bibitem{" write$

  cite$ write$
  "}" write$
  newline$
  "  \ifshowBIBTYPE " type$ "bibtype" wrap * "{" * cite$ * "} \fi " * write$
  % newline$
  ""
  before.all 'output.state :=
}

%%: No longer used: comment out to reduce function count (maximum 100 in old BibTeX)
%%: FUNCTION {fin.entry}
%%: {
%%:   %% Finish off an entry by writing the extra fields, any needed
%%:   %% punctuation, and a newline.  On return, the BibTeX output buffer
%%:   %% should be empty, and the output .bbl file should end with a
%%:   %% non-blank line followed by an end-of-line character.
%%:   %%
%%:   %% At entry: stack = (top==0):[string]
%%:   %% At exit:  stack = empty
%%:
%%:   add.period$
%%:   write$
%%:   newline$
%%: }

FUNCTION {finish.entry}
{
  %% Finish off an entry with a newline.  On return, the BibTeX output
  %% buffer should be empty, and the output .bbl file should end with
  %% a non-blank line followed by an end-of-line character.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  newline$
}

FUNCTION {new.block}
{
  %% Update the output.state to indicate that we are either in state
  %% before.all (after the \bibitem, but before any other data), or in
  %% state after.block, ready to start a new block.  A new block is
  %% later identified by a \newblock macro, which expands to a bit of
  %% horizontal space (default closebib style), or to a paragraph
  %% break (openbib style).
  %%
  %% At entry: stack = ... top:[top-string]
  %% At exit:  stack = ... top:[top-string]
  %%
  %% Global variables set: output.state

  output.state before.all =
    'skip$
    { after.block 'output.state := }
  if$
}

FUNCTION {new.sentence}
{
  %% Update the output.state to indicate that we are either in state
  %% before.all (after the \bibitem, but before any other data), or in
  %% state after.sentence, ready to start a new sentence or new block.
  %%
  %% At entry: stack = ... top:[top-string]
  %% At exit:  stack = ... top:[top-string]
  %%
  %% Global variables set: output.state

  output.state after.block =
    'skip$
    { output.state before.all =
        'skip$
        { after.sentence 'output.state := }
      if$
    }
  if$
}

FUNCTION {write.string}
{
  %% Pop and output the top-of-stack string, WITHOUT adding a final
  %% period.  The assumption is that each format.xxx function leaves
  %% the stack with exactly one entry.  This function is normally used
  %% after each optional field value is handled.
  %%
  %% At entry: stack = (top==0):[string]
  %% At exit:  stack = empty

  duplicate$ empty$
    'pop$
    'write$
  if$
}

FUNCTION {write.string.with.period}
{
  %% Pop and output the top-of-stack string, with any needed final
  %% period.  The assumption is that each format.xxx function leaves
  %% the stack with exactly one entry, a string awaiting final
  %% punctuation and output.  This function is normally used before
  %% the sequence of optional field values are handled.
  %%
  %% At entry: stack = (top==0):[string]
  %% At exit:  stack = empty

  new.sentence
  add.period$ " " *
  write$
}


FUNCTION {and}
{
  %% Compute the Boolean AND of the top two stack arguments, replacing
  %% them by the result (0 or 1).
  %%
  %% At entry: stack = ... top-2:[some-value] top-1:[integer] top:[integer]
  %% At exit:  stack = ... top-1:[some-value] top:[0 or 1]

   'skip$
    { pop$ #0 }
  if$
}

FUNCTION {not}
{
  %% Replace the top stack element by its Boolean negation (0 ==
  %% false, 1 == true).  A zero is coerced to Boolean false, and a
  %% non-zero to Boolean true.
  %%
  %% At entry: stack = ... top-1:[some-value] top:[integer]
  %% At exit:  stack = ... top-1:[some-value] top:[0 or 1]

    { #0 }
    { #1 }
  if$
}

FUNCTION {or}
{
  %% Compute the Boolean OR of the top two stack arguments, replacing them
  %% by the result (0 or 1).
  %%
  %% At entry: stack = ... top-2:[some-value] top-1:[integer] top:[integer]
  %% At exit:  stack = ... top-1:[some-value] top:[0 or 1]

   { pop$ #1 }
    'skip$
  if$
}


FUNCTION {new.block.checka}
{
  %% Pop the top-of-stack.  If it was empty or unknown, start a new
  %% block in the .bbl file.
  %%
  %% At entry: stack = ... top-1:[top-1-string] top:[top-string]
  %% At exit:  stack = ... top:[top-1 string]

  empty.or.unknown
    'skip$
    'new.block
  if$
}

FUNCTION {new.block.checkb}
{
  %% Pop the top two elements.  If both were empty or unknown, start a
  %% new block in the .bbl file.
  %%
  %% At entry: stack = ... top-2:[top-2-string] top-1:[top-1-string] top:[top-string]
  %% At exit:  stack = ... top:[top-2-string]

  empty.or.unknown
  swap$ empty.or.unknown
  and
    'skip$
    'new.block
  if$
}


FUNCTION {new.sentence.checka}
{
  %% Pop the top-of-stack.  If it was empty or unknown, start a new
  %% sentence in the .bbl file.
  %%
  %% At entry: stack = ... top-1:[top-1-string] top:[top-string]
  %% At exit:  stack = ... top:[top-1 string]

  empty.or.unknown
    'skip$
    'new.sentence
  if$
}

FUNCTION {new.sentence.checkb}
{
  %% Pop the top two elements.  If both were empty or unknown, start a
  %% new sentence in the .bbl file.
  %%
  %% At entry: stack = ... top-2:[top-2-string] top-1:[top-1-string] top:[top-string]
  %% At exit:  stack = ... top:[top-2-string]

  empty.or.unknown
  swap$ empty.or.unknown
  and
    'skip$
    'new.sentence
  if$
}


FUNCTION {field.or.null}
{
  %% If the top stack element is empty or unknown, replace it by a
  %% null string. Otherwise, leave it alone.
  %%
  %% At entry: stack = ... top:[string]
  %% At exit:  stack = ... top:[string]
  %%      or:  stack = ... top:[""]

  duplicate$ empty.or.unknown
    { pop$ "" }
    'skip$
  if$
}

FUNCTION {emphasize}
{
  %% Emphasize the top string on the stack, WITHOUT an italic
  %% correction (because a period or comma will follow).
  %%
  %% At entry: stack = ... top:["string"]
  %% At exit:  stack = ... top:["{\em string}"]

  duplicate$ empty.or.unknown
    { pop$ "" }
    { "{\em " swap$ * "}" * }
  if$
}

INTEGERS { nameptr namesleft numnames }

FUNCTION {format.names}
{
  %% Format bibliographical entries with authors in the name order
  %% "A. U. Thor" (abbreviated) or "Arthur Ulysses Thor" (full),
  %% as a list "person, person, person, ..., person, and person".
  %% All names are formatted in this routine.
  %%
  %% At entry: stack = ... top:[name1 and name2 and name3 and ...]
  %% At exit:  stack = ... top:[list of formatted names]
  %%
  %% Global variables set: nameptr, namesleft, numnames, s, t

  's :=
  #1 'nameptr :=
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }

    { s nameptr "{ff~}{vv~}{ll}{, jj}" format.name$ 't :=

      nameptr #1 >
        { namesleft #1 >
            { ", " * t * }
            { numnames #2 >
                { "," * }
                'skip$
              if$
              t "others" =
                { " et~al." * }
                { " and " * t * }
              if$
            }
          if$
        }
        't
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
}

FUNCTION {format.authors}
{
  %% Format an author list for typesetting.  An empty or unknown list is
  %% converted to a null string.
  %%
  %% At entry: stack = ... top:[name1 and name2 and name3 and ...]
  %% At exit:  stack = ... top:[formatted author list]
  %%      or:  stack = ... top:[""]

  author empty.or.unknown
    { "" }
    {
      author "authorraw" wrap
      author format.names "author" wrap *
    }
  if$
}


FUNCTION {format.doi}
{
  %% For clarity, we assign the DOI value, or an empty string,
  %% to the temporary variable t, then strip common prefixes.
  doi empty.or.unknown
    { ""  }
    { doi }
  if$ 't :=

  %%-------------------123456789.123456789.123456789.123456789.
  t #1 #28 substring$ "http://www.pnas.org/cgi/doi/" =
    { t #29 t text.length$ #28 - substring$ }
    { t }
  if$ 't :=

  %%-------------------123456789.123456789.123456789.123456789.
  t #1 #29 substring$ "https://www.pnas.org/cgi/doi/" =
    { t #30 t text.length$ #29 - substring$ }
    { t }
  if$ 't :=

  %%-------------------123456789.123456789.123456789.123456789.
  t #1 #35 substring$ "http://doi.ieeecomputersociety.org/" =
    { t #36 t text.length$ #35 - substring$ }
    { t }
  if$ 't :=

  %%-------------------123456789.123456789.123456789.123456789.
  t #1 #36 substring$ "https://doi.ieeecomputersociety.org/" =
    { t #37 t text.length$ #36 - substring$ }
    { t }
  if$ 't :=

  %%-------------------123456789.123456789.123456789.123456789.
  t #1 #19 substring$ "http://doi.acm.org/" =
    { t #20 t text.length$ #19 - substring$ }
    { t }
  if$ 't :=

  %%-------------------123456789.123456789.123456789.123456789.
  t #1 #20 substring$ "https://doi.acm.org/" =
    { t #21 t text.length$ #20 - substring$ }
    { t }
  if$ 't :=

  %%-------------------123456789.123456789.123456789.123456789.
  t #1 #18 substring$ "http://dx.doi.org/" =
    { t #19 t text.length$ #18 - substring$ }
    { t }
  if$ 't :=

  %%-------------------123456789.123456789.123456789.123456789.
  t #1 #19 substring$ "https://dx.doi.org/" =
    { t #20 t text.length$ #19 - substring$ }
    { t }
  if$ 't :=

  %%-------------------123456789.123456789.123456789.123456789.
  t #1 #15 substring$ "http://doi.org/" =
    { t #16 t text.length$ #15 - substring$ }
    { t }
  if$ 't :=

  %%-------------------123456789.123456789.123456789.123456789.
  t #1 #16 substring$ "https://doi.org/" =
    { t #17 t text.length$ #16 - substring$ }
    { t }
  if$ 't :=

  doi empty.or.unknown
    { "" }
    {
      newline$
      new.block
      "\newblock \ifshowDOI {\showDOI \url{" t * "}}\ifshowDOIPERIOD . \fi \fi " *
    }
  if$
}


FUNCTION {format.editors}
{ editor empty.or.unknown
    { "" }
    {
      editor "editorraw" wrap
      editor format.names "editor" wrap *

      editor num.names$ #1 >
        { ", editors" * }
        { ", editor" * }
      if$
    }
  if$
}


FUNCTION {format.title}
{ title empty.or.unknown
    { "" }

    { title "t" change.case$ }

  if$
  "title" wrap
}



FUNCTION {collapse.pagerange}
{ 't :=				% save input page range string
  t 'original.t :=		% save original page range
  "" 'b :=			% beginning page number
  "" 'e :=			% ending page number
    { t empty.or.unknown not }		% while-loop Boolean condition
    {				% while-loop body
      t #1 #2 substring$ "--" =	% have we found the en-dash?
	{
	   t #3 global.max$ substring$ 'e :=	% yes, save ending page number
	   "" 't := 		% and set t to empty string to terminate loop
	}
	{
	   b t #1 #1 substring$ * 'b := % no, just accumulate this character
	   t #2 global.max$ substring$ 't := % and set t to the remaining string
	}
      if$
    }
  while$			% on exit, t has ending page number string
  e b =				% are beginning and ending numbers the same?
    { b	}			% yes, return the beginning page number string
    { original.t }		% no, return the original page number string
  if$
}


FUNCTION {n.dashify}
{ 't :=
  ""
    { t empty.or.unknown not }
    { t #1 #1 substring$ "-" =
        { t #1 #2 substring$ "--" = not
            { "--" *
              t #2 global.max$ substring$ 't :=
            }
            {   { t #1 #1 substring$ "-" = }
                { "-" *
                  t #2 global.max$ substring$ 't :=
                }
              while$
            }
          if$
        }
        { t #1 #1 substring$ *
          t #2 global.max$ substring$ 't :=
        }
      if$
    }
  while$
}


FUNCTION {format.date}
{
  %% Format a date (day, month, year) for typesetting.  Warnings are
  %% issued if these values are inconsistent.
  %%
  %% The possible output strings (ignoring field wrapping) are:
  %%
  %%	""				-- day/month/year empty: okay
  %%	"January 2001"			-- day unset: okay
  %%    "2001"				-- day/month unset: okay
  %%    "2001"				-- month unset: issue warning, discard day
  %%    "January"			-- day/year unset: issue warning
  %%    "January 1"			-- year unset: issue warning
  %%	"January 1, 2001"		-- day/month/year set
  %%
  %% At entry: stack = ... top:[top-string]
  %% At exit:  stack = ... top-1:[top-string] ["month day, year"]
  %%      or:  stack = ... top-1:[top-string] ["month, year"]
  %%      or:  stack = ... top-1:[top-string] ["year"]
  %%      or:  stack = ... top-1:[top-string] [""]

  year empty.or.unknown
    {
      month empty.or.unknown
        {
          ""                    % output empty date if year/month both empty, and discard day
	  day empty.or.unknown
	    {  }
	    { "there's a day but no month or year in " cite$ * warning$ }
	  if$
	}
        {
          "there's a month but no year in " cite$ * warning$
	  month "month" wrap
	  day empty.or.unknown
            { }
	    { " " * day "day" wrap * }
          if$
        }
      if$
    }
    { % else year is set
      month empty.or.unknown
	{
	  ""
	  day empty.or.unknown
	    {  }
	    { "there's a day and year but no month in " cite$ * warning$ } % discard day
	  if$
	}
        {
	  month "month" wrap " " *
	  day empty.or.unknown
            { }
	    { day "day" wrap * ", " * }
          if$
        }
      if$
      year "year" wrap *
    }
  if$
}

FUNCTION {format.date.old}
{ year empty$
    { month empty$
        {
          ""                    % output empty date if year/month both empty
	  day empty$
	    {  }
	    { "there's a day but no month or year in " cite$ * warning$ }
	  if$
	}
        { "there's a month but no year in " cite$ * warning$
          month
	  day empty$
            { }
	    { " " * day * }
          if$
        }
      if$
    }
    { month empty$
	{
          year                  % output only year if month empty
	  day empty$
	    {  }
	    { "there's a day and year but no month in " cite$ * warning$ }
	  if$
	}
        {
          month " " *
	  day empty$
            { }
	    { day * ", " * }
          if$
          year *
        }
      if$
    }
  if$
}



FUNCTION {format.btitle}
{
  title "title" wrap emphasize
}


FUNCTION {tie.or.space.connect}
{
  %% Join the top two stack entries with a space or tie.  The tie
  %% is used only if the top entry is one or two characters long.
  %%
  %% At entry: stack = ... top-1:[top-1-string] top:[top-string]
  %% At exit:  stack = ... top:[top-1-string top-string]
  %%      or:  stack = ... top:[top-1-string~top-string]

 duplicate$ text.length$ #3 <
    { "~" }
    { " " }
  if$
  swap$ * *
}


FUNCTION {either.or.check}
{
  %% Check that just one of the top two stack entries is defined, and
  %% issue a warning if both are defined.
  %%
  %% At entry: stack = ... top-2:[top-2-string] top-1:[key1] top:[key2]
  %% At exit:  stack = ... top:[top-2-string]

  empty.or.unknown
    'pop$
    { "can't use both " swap$ * " fields in " * cite$ * warning$ }
  if$
}


FUNCTION {format.bvolume}
{
  volume empty.or.unknown
    { "" }
    { "volume" volume tie.or.space.connect
      series empty.or.unknown
        'skip$
        { " of " * series "series" wrap emphasize * }
      if$
      "volume and number" number either.or.check
    }
  if$
}


FUNCTION {format.number.series}
{
  %% Format a number and series for typesetting, and check that series
  %% is defined if the number is.
  %%
  %% At entry: stack = ... top:[top-string]
  %% At exit:  stack = ... top-1:[top-string] top:[formatted and wrapped number and series]

 volume empty.or.unknown
    { number empty.or.unknown
        { series "series" wrap }
        { output.state mid.sentence =
            { "number" }
            { "Number" }
          if$
          number tie.or.space.connect
          series empty.or.unknown
            { "there's a number but no series in " cite$ * warning$ }
            { " in " * series "series" wrap * }
          if$
        }
      if$
    }
    { "" }
  if$
}


FUNCTION {format.edition}
{ edition empty.or.unknown
    { "" }
    { output.state mid.sentence =
        { edition "l" change.case$ "edition" wrap " edition" * }
        { edition "t" change.case$ "edition" wrap " edition" * }
      if$
    }
  if$
}


INTEGERS { multiresult }

FUNCTION {multi.page.check}
{
  %% Given a page list on the top-of-stack, examine it to see if it
  %% references multiple pages (as evidenced by a comma, hyphen, or
  %% plus).  Replace the top-of-stack by 0 (single page) or 1 (multiple
  %% pages).
  %%
  %% At entry: stack = ... top:[page list]
  %% At exit:  stack = ... top:[0 or 1]
  %%
  %% Global variables set: multiresult, t

  't :=
  #0 'multiresult :=
    { multiresult not
      t empty.or.unknown not
      and
    }
    { t #1 #1 substring$
      duplicate$ "-" =
      swap$ duplicate$ "," =
      swap$ "+" =
      or or
        { #1 'multiresult := }
        { t #2 global.max$ substring$ 't := }
      if$
    }
  while$
  multiresult
}

FUNCTION {format.bookpages}
{
  %% Format a list of book pages for typesetting.  An empty or unknown
  %% list is converted to a empty string. Also, if bookpages is the
  %% same as pages, produce an empty string.
  %%
  %% At entry: stack = ... top:[book-pages]
  %% At exit:  stack = ... top:[wrapped-book-pages]


  bookpages empty.or.unknown
  crossref empty.or.unknown not  % omit bookpages when it is given elsewhere in a cross reference
  or
    { "" }
    {
      bookpages pages =
        { "" }
        {    
	  pages empty.or.unknown
	    { " "     bookpages "bookpages" wrap *       }
	    { " [of " bookpages "bookpages" wrap * "]" * }
	  if$
        }
      if$
    }
  if$

}

FUNCTION {format.pagecount}
{
  %% Format a pagecount value.  A prefixing comma-space is included
  %% for a nonempty pagecount, so the result can be concatenated to
  %% a previous string.  If the pagecount is empty, the output string
  %% is empty.
  %%
  %% At entry: stack = ... top:[top-string]
  %% At exit:  stack = ... top-1:[top-string] top:[", 23 pp."]
  %%      or:  stack = ... top-1:[top-string] top:[", 1 p."]
  %%      or:  stack = ... top-1:[top-string] top:[""]

  pagecount empty.or.unknown
    { "" }
    { 
      pagecount "1" =
        { pagecount "pagecountone" wrap }
        { pagecount "pagecount"    wrap }
      if$
    }
  if$
}


FUNCTION {format.pages}
{
  %% Format a pages list for typesetting.
  %%
  %% At entry: stack = ... top:[top-string]
  %% At exit:  stack = ... top-1:[top-string] top:[formatted and wrapped pages]
  %%      or:  stack = ... top-1:[top-string] top:[""]
  %%
  %% Global variables set: new.pages

  pages empty.or.unknown
    { "" }
    {
      pages multi.page.check
        { pages collapse.pagerange }
	{ pages }
      if$
      'new.pages :=
      new.pages multi.page.check
        { "pages" new.pages n.dashify "pages" wrap tie.or.space.connect }
        { "page"  new.pages           "pages" wrap tie.or.space.connect }
      if$
    }
  if$

  format.bookpages *
}

FUNCTION {format.pages.of.book}
{
  %% Format a pages list for typesetting.
  %%
  %% At entry: stack = ... top:[top-string]
  %% At exit:  stack = ... top-1:[top-string] top:[formatted and wrapped pages]
  %%      or:  stack = ... top-1:[top-string] top:[""]
  %%
  %% Global variables set: new.pages

  pages empty.or.unknown
    { "" }
    { pages "pages" wrap " pp." * }
  if$

  format.bookpages *
}


FUNCTION {format.vol.num.pages}
{
  %% Format the volume, number, and page range of a journal article.
  %% We use the format: vol(number):pages, with some variations for
  %% empty fields, and insertion of a \penalty 0 after the colon.
  %% This doesn't begin a sentence.
  %%
  %% If pages is empty or unknown, and articleno, and possibly
  %% pagecount, are provided, then the pages output location is filled
  %% instead with something like ", Article 034501, 4 pages" or ", Article
  %% 1257".  That accommodates a new style adopted by some journals
  %% in computer science and the physical sciences after the year 2000.
  %%
  %% Possible output strings (ignoring value wrappers and penalties) are:
  %%
  %%	"v(n):pp"
  %%	"v(n)"
  %%	"v:pp"
  %%	"(n):pp"	% with warning about missing volume
  %%	"(n)"		% with warning about missing volume
  %%	"pp"
  %%	"page~p"	% only if stack top string at entry is empty
  %%	"pages~pp"	% only if stack top string at entry is empty
  %%
  %% At entry: stack = ...   top:[old-string]
  %% At exit:  stack = ... top-1:[old-string] top:[formatted volume, number, pages]


  volume empty.or.unknown
    { "" }
    { volume "volume" wrap }
  if$

  number empty.or.unknown
    'skip$
    {
      "\penalty 0 (" number "number" wrap * ")" * *
      volume empty.or.unknown
        { "there's a number but no volume in " cite$ * warning$ }
        'skip$
      if$
    }
  if$

  pages empty.or.unknown
    {
      articleno empty.or.unknown
        { format.pagecount * }
        { ", " * articleno "articleno" wrap * format.pagecount * }
      if$
    }
    { 
      % Warn if pages and either articleno or pagecount is also set.
      articleno empty.or.unknown not
      pagecount empty.or.unknown not or
        { "articleno and pagecount ignored because pages is set in " cite$ * warning$ }
        { }
      if$

      duplicate$ empty.or.unknown
        { pop$ format.pages }
        { ":\penalty 0 " * pages collapse.pagerange n.dashify "pages" wrap * }
      if$
    }
  if$
}


FUNCTION {format.chapter.pages}
{
  %% Format chapter and pages for typesetting for @InBook{...} and
  %% @InCollection{...} entries.  Warn if the pages are missing.
  %%
  %% At entry: stack = ... top:[top-string]
  %% At exit:  stack = ... top-1:[top-string] top:[formatted chapter and pages]

  chapter empty.or.unknown
    'format.pages
    { type empty.or.unknown
        { "chapter" }
        { type "l" change.case$ }
      if$
      chapter "chapter" wrap tie.or.space.connect
      pages empty.or.unknown
        'skip$
        { ", " * format.pages * }
      if$
    }
  if$
}


FUNCTION {format.in.ed.booktitle}
{
  %% Format editors and booktitle for @InCollection{...} and
  %% @InProceedings{...} entries.
  %%
  %% At entry: stack = ... top:[top-string]
  %% At exit:  stack = ... top-1:[top-string] top:[In wrapped-editors, wrapped-booktitle]
  %%      or:  stack = ... top-1:[top-string] top:[In wrapped-booktitle]

  booktitle empty.or.unknown
    { "" }
    { editor empty.or.unknown
        { "In " booktitle "booktitle" wrap emphasize * }
        {
          "In " editor "editorraw" wrap *
                format.editors "editor" wrap *
                ", " *
                booktitle "booktitle" wrap emphasize *
        }
      if$
    }
  if$
}


FUNCTION {empty.misc.check}
{ author empty.or.unknown title empty.or.unknown howpublished empty.or.unknown
  month empty.or.unknown year empty.or.unknown note empty.or.unknown
  and and and and and

  key empty.or.unknown not and

    { "all relevant fields are empty in " cite$ * warning$ }
    'skip$
  if$
}


FUNCTION {format.thesis.type}
{
  %% Format a thesis type for typesetting.  The top-of-stack contains a
  %% default type to use if the type is not specified in the BibTeX
  %% entry.
  %%
  %% At entry: stack = ... top: [default-type]
  %% At exit:  stack = ... top: [wrapped-non-empty-known-type-or-else-default-type]

  type empty.or.unknown
    'skip$
    { pop$
      % NB: Suppress case change of degree names, which was a historical
      % mistake that has caused many errors in published bibliographies.
      % type "t" change.case$
      type
    }
  if$
  "type" wrap
}


FUNCTION {format.tr.number}
{
  %% Format a technical report name and number for typesetting.
  %%
  %% At entry: stack = ... top:[top-string]
  %% At exit:  stack = ... top-1:[top-string] top:[wrapped-type wrapped-number]
  %%      or:  stack = ... top-1:[top-string] top:[wrapped-type]

  type empty.or.unknown
    { "Technical Report" }
    'type
  if$
  number empty.or.unknown
    { "t" change.case$ }
    { number "number" wrap tie.or.space.connect }
  if$
}


FUNCTION {format.article.crossref}
{
  %% Format an article cross reference for typesetting.
  %%
  %% At entry: stack = ... top:[top-string]
  %% At exit:  stack = ... top-1:[top-string] top:["???? TO-DO ????"]

  key empty.or.unknown
    { journal empty.or.unknown
        { "need key or journal for " cite$ * " to crossref " * crossref *
          warning$
          ""
        }
        { "In {\em " journal "journal" wrap * "\/}" * }
      if$
    }
    { "In " key "key" wrap * }
  if$
  " \cite{" * crossref "crossref" wrap * "}" *
}


FUNCTION {format.crossref.editor}
{
  %% Format an editor list for @Book{...} and @InBook{...}  entries.
  %%
  %% At entry: stack = ... top:[top-string]
  %% At exit:  stack = ... top-1:[top-string] top:[formatted list]

  editor #1 "{vv~}{ll}" format.name$
  editor num.names$ duplicate$
  #2 >
    { pop$ " et~al." * }
    { #2 <
        'skip$
        { editor #2 "{ff }{vv }{ll}{ jj}" format.name$ "others" =
            { " et~al." * }
            { " and " * editor #2 "{vv~}{ll}" format.name$ * }
          if$
        }
      if$
    }
  if$
}


FUNCTION {format.book.crossref}
{
  %% Format a volume and author/editor list cross reference for
  %% @Book{...} and @InBook{...}  entries.
  %%
  %% At entry: stack = ... top:[top-string]
  %% At exit:  stack = ... top-1:[top-string] top:[formatted list]

  volume empty.or.unknown
    { "empty volume in " cite$ * "'s crossref of " * crossref * warning$
      "In "
    }
    { "Volume" volume tie.or.space.connect
      " of " *
    }
  if$
  editor empty.or.unknown
  editor field.or.null author field.or.null =
  or
    { key empty.or.unknown
        { series empty.or.unknown
            { "need editor, key, or series for " cite$ * " to crossref " *
              crossref * warning$
              "" *
            }
            { "{\em " * series "series" wrap * "\/}" * }
          if$
        }
        { key "key" wrap }
      if$
    }
    { format.crossref.editor * }
  if$
  " \cite{" * crossref "crossref" wrap * "}" *
}


FUNCTION {format.incoll.inproc.crossref}
{
  %% Format an @InCollection{...} or @InProceedings{...} cross reference
  %% for typesetting.
  %%
  %% At entry: stack = ... top:[top-string]
  %% At exit:  stack = ... top-1:[top-string] top:["???? TO-DO ????"]

  editor empty.or.unknown
  editor field.or.null author field.or.null =
  or
    { key empty.or.unknown
        { booktitle empty.or.unknown
            { "need editor, key, or booktitle for " cite$ * " to crossref " *
              crossref * warning$
              ""
            }
            { "In {\em " booktitle "booktitle" wrap * "\/}" * }
          if$
        }
        { "In " key "key" wrap * }
      if$
    }
    { "In " format.crossref.editor * }
  if$
  " \cite{" * crossref "crossref" wrap * "}" *
}

FUNCTION {write.coden}
{
  %% Write CODEN to output file, leaving stack untouched (and it should be empty!)

  coden empty.or.unknown
    { "" }
    { "\ifshowCODEN {" coden "coden" wrap * "}. \fi " *}
  if$
  write.string

}

FUNCTION {write.doi}
{
  %% Write DOI to output file, leaving stack untouched (and it should be empty!)

  format.doi write.string

}

FUNCTION {write.isbn}
{
  %% Write ISBN and ISBN-13 to output file, leaving stack untouched (and it should be empty!)

 isbn empty.or.unknown
    {
      isbn-13 empty.or.unknown
	{ "" }
	{ "\ifshowISBN {" isbn-13 "isbn" wrap * "}. \fi " * }
      if$
    }
    {
      new.block
      "\ifshowISBN {"
      isbn "isbn" wrap *
      isbn-13 empty.or.unknown
	{ "" }
	{ "; " * isbn-13 "isbnxiii" wrap * }
      if$
      "}. \fi " *
    }
  if$
  write.string

}

FUNCTION {write.issn}
{
  %% Write ISSN to output file, leaving stack untouched (and it should be empty!)

 issn empty.or.unknown
    { "" }
    { "\ifshowISSN {" issn "issn" wrap * "}. \fi " * }
  if$
  write.string

}

FUNCTION {write.issnl}
{
  %% Write ISSN-L to output file, leaving stack untouched (and it should be empty!)

  issn-l empty.or.unknown
    { "" }
    % OLD else block: { new.block "\ifshowISSNL {\showISSNL{" issn-l * "}}. \fi " *}
    { % NEW else block: omit ISSN-L if identical to ISSN
      issn issn-l =
        { "" }
        { "\ifshowISSNL {" issn-l "issnl" wrap * "}. \fi " * }
      if$
    }
  if$
  write.string

}

FUNCTION {write.lccn}
{
  %% Write LCCN to output file, leaving stack untouched (and it should be empty!)

  lccn empty.or.unknown
    { "" }
    { "\ifshowLCCN {" lccn "LCCN" wrap * "}. \fi " *}
  if$
  write.string

}

FUNCTION {write.note}
{
  %% Write note to output file, leaving stack untouched (and it should be empty!)
  new.block
  note empty.or.unknown
    { "" }
    { note "note" wrap }
  if$
  write.string.with.period
}

FUNCTION {write.price}
{
  %% Write price to output file, leaving stack untouched (and it should be empty!)

  price empty.or.unknown
    { "" }
    { "\ifshowPRICE {" price "price" wrap * "}. \fi " *}
  if$
  write.string

}

FUNCTION {write.url}
{
  %% Write URL to output file, leaving stack untouched (and it should be empty!)

  url empty.or.unknown
    { "" }
    { newline$
      new.block
      "\newblock \ifshowURL {\showURL \url{" url * "}}. \fi " *}
  if$
  write.string

}

FUNCTION {write.others}
{
  write.string.with.period
  write.coden
  write.isbn
  write.issn
  write.issnl
  write.lccn
  write.price
  write.url
  write.note
  write.doi
}


FUNCTION {article}
{
  %% Write an @Article{...} entry.
  %%
  %% Typical value [in Chicago style] (CMoS-14, p. 647):
  %%
  %%     Arnold, M. L., R. L. Honeycutt, R. J. Baker, V. M. Sarich, and
  %%       J. K. Jones, Jr. 1982. Resolving a phylogeny with multiple
  %%       data sets: A systematic study of phyllostomid bats. {\em
  %%       Occas. Pap. Museum, Texas Tech Univ.\/} 77:1--15.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block

  crossref missing$
    {
      journal "journal" wrap.required emphasize "journal" output.check
      format.vol.num.pages output
      format.date "year" output.check
    }
    {
      format.article.crossref output.nonnull
      format.pages output
    }
  if$

  write.others
  finish.entry
}

FUNCTION {book}
{
  %% Write a @Book{...} entry.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  output.bibitem
  author empty.or.unknown
    { format.editors "author and editor" output.check }
    { format.authors output.nonnull
      crossref missing$
        { "author and editor" editor either.or.check }
        'skip$
      if$
    }
  if$
  new.block
  format.btitle "title" output.check
  crossref missing$
    { format.bvolume output
      new.block
      format.number.series output
      new.sentence
      publisher "publisher" wrap "publisher" output.check
      address "address" wrap output
    }
    { new.block
      format.book.crossref output.nonnull
    }
  if$
  format.edition output
  format.date "year" output.check
  format.pages.of.book output
  write.others
  finish.entry
}


FUNCTION {booklet}
{
  %% Write a @Booklet{...} entry.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  output.bibitem
  format.authors output
  new.block
  format.title "title" output.check
  howpublished address new.block.checkb
  howpublished "howpublished" wrap output
  address "address" wrap output
  format.date output
  format.pages.of.book output
  write.others
  finish.entry
}



FUNCTION {inbook}
{
  %% Write an @InBook{...} entry.
  %%
  %% Typical value [in Chicago style] (CMoS-14, p. 647):
  %%
  %%     August, P. V. 1979.  Distress calls in {\em Artibeus
  %%       jamaicensis\/}: Ecology and evolutionary implications. In
  %%       {\em Vertebrate ecology in northern Neotropics\/},
  %%       ed. J. F. Eisenberg, 151--59.  Washington, D.C.: Smithsonian
  %%       Institute Press.
  %%
  %% NB: The elided leading digits in the page number range in this
  %%     example are intentionally NOT supported by this BibTeX style:
  %%     they are a senseless economization.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  output.bibitem
  author empty.or.unknown
    { format.editors "author and editor" output.check }
    { format.authors output.nonnull
      crossref missing$
        { "author and editor" editor either.or.check }
        'skip$
      if$
    }
  if$
  new.block
  format.btitle "title" output.check
  crossref missing$
    { format.bvolume output
      format.chapter.pages "chapter and pages" output.check
      new.block
      format.number.series output
      new.sentence
      publisher "publisher" wrap "publisher" output.check
      address "address" wrap output
    }
    { format.chapter.pages "chapter and pages" output.check
      new.block
      format.book.crossref output.nonnull
    }
  if$
  format.edition output
  format.date "year" output.check
  write.others
  finish.entry
}


FUNCTION {incollection}
{
  %% Write an @InCollection{...} entry.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  crossref missing$
    { format.in.ed.booktitle "booktitle" output.check
      format.bvolume output
      format.number.series output
      format.chapter.pages output
      new.sentence
      publisher "publisher" wrap "publisher" output.check
      address "address" wrap output
      format.edition output
      format.date "year" output.check
    }
    { format.incoll.inproc.crossref output.nonnull
      format.chapter.pages output
    }
  if$
  write.others
  finish.entry
}


FUNCTION {inproceedings}
{
  %% Write an @InProceedings{...} entry.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  crossref missing$
    {
      format.in.ed.booktitle "booktitle" output.check
      format.bvolume output
      format.number.series output
      format.pages output
      address empty.or.unknown
        {
          organization publisher new.sentence.checkb
	  organization "organization" wrap output
	  publisher    "publisher"    wrap output
        }
        {
          new.sentence
	  organization "organization" wrap output
	  publisher    "publisher"    wrap output
	  address      "address"      wrap output
        }
      if$
      format.date "year" output.check
    }
    {
      format.incoll.inproc.crossref output.nonnull
      format.pages output
    }
  if$
  write.others
  finish.entry
}

FUNCTION {conference}                   % Scribe alias for BibTeX equivalent
{
  %% Write a @Conference{...} (== @InProceedings{...}) entry.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  inproceedings                         % reuse common code
}


FUNCTION {manual}
{
  %% Write a @Manual{...} entry.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  output.bibitem
  author empty.or.unknown
    { organization empty.or.unknown
        'skip$
        {
          organization "organization" wrap output.nonnull
          address "address" wrap output
        }
      if$
    }
    { format.authors output.nonnull }
  if$
  new.block
  format.btitle "title" output.check
  author empty.or.unknown
    { organization empty.or.unknown
        { address new.block.checka
          address "address" wrap output
        }
        'skip$
      if$
    }
    { organization address new.block.checkb
      organization "organization" wrap output
      address "address" wrap output
    }
  if$
  format.edition output
  format.date output
  format.pages.of.book output
  write.others
  finish.entry
}


FUNCTION {mastersthesis}
{
  %% Write a @MastersThesis{...} entry.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  "Master's thesis" format.thesis.type output.nonnull
  school "school" wrap "school" output.check
  address "address" wrap output
  format.date "year" output.check
  format.pages.of.book output
  write.others
  finish.entry
}


FUNCTION {misc}
{
  %% Write a @Misc{...} entry.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  output.bibitem
  format.authors output
  title howpublished new.block.checkb
  format.title output
  howpublished new.block.checka
  howpublished "howpublished" wrap output
  format.date output
  write.others
  finish.entry
  empty.misc.check
}


FUNCTION {periodical}
{
  %% Write a @Periodical{...} entry.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  output.bibitem
  editor empty.or.unknown
    {
      organization "organization" wrap output
    }
    { format.editors output.nonnull }
  if$
  new.block
  title emphasize "title" output.check
  format.vol.num.pages output
  format.date output
  new.sentence
  publisher "publisher" wrap output
  address "address" wrap output
  howpublished new.block.checka
  howpublished "howpublished" wrap output
  write.others
  finish.entry
}


FUNCTION {phdthesis}
{
  %% Write a @PhDThesis{...} entry.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  output.bibitem
  format.authors "author" output.check
  new.block
  format.btitle "title" output.check
  new.block
  "PhD thesis" format.thesis.type output.nonnull
  school "school" wrap "school" output.check
  address "address" wrap output
  format.date "year" output.check
  format.pages.of.book output
  write.others
  finish.entry
}


FUNCTION {proceedings}
{
  %% Write a @Proceedings{...} entry.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  output.bibitem
  editor empty.or.unknown
    {
      organization "organization" wrap output
    }
    { format.editors output.nonnull }
  if$
  new.block
  format.btitle "title" output.check
  format.bvolume output
  format.number.series output
  address empty.or.unknown
    { editor empty.or.unknown
        { publisher new.sentence.checka }
        { organization publisher new.sentence.checkb
          organization "organization" wrap output
        }
      if$
      publisher "publisher" wrap "publisher" output.check %%% <- new check for missing
      format.date "year" output.check
    }
    { new.sentence
      editor empty.or.unknown
        'skip$
        {
          organization "organization" wrap output
        }
      if$
      publisher "publisher" wrap "publisher" output.check
      address "address" wrap output.nonnull
      format.date "year" output.check
    }
  if$
  format.pages.of.book output
  write.others
  finish.entry
}


FUNCTION {techreport}
{
  %% Write a @TechReport{...} entry.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  format.tr.number output.nonnull
  institution "institution" wrap "institution" output.check
  address "address" wrap output
  format.date "year" output.check
  format.pages.of.book output
  write.others
  finish.entry
}


FUNCTION {unpublished}
{
  %% Write an @Unpublished{...} entry.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  format.date "year" output.check
  format.pages.of.book output
  write.others
  finish.entry
}


FUNCTION {default.type} { misc }




MACRO {jan} {"January"}

MACRO {feb} {"February"}

MACRO {mar} {"March"}

MACRO {apr} {"April"}

MACRO {may} {"May"}

MACRO {jun} {"June"}

MACRO {jul} {"July"}

MACRO {aug} {"August"}

MACRO {sep} {"September"}

MACRO {oct} {"October"}

MACRO {nov} {"November"}

MACRO {dec} {"December"}






MACRO {acmcs} {"ACM Computing Surveys"}

MACRO {acta} {"Acta Informatica"}

MACRO {cacm} {"Communications of the ACM"}

MACRO {ibmjrd} {"IBM Journal of Research and Development"}

MACRO {ibmsj} {"IBM Systems Journal"}

MACRO {ieeese} {"IEEE Transactions on Software Engineering"}

MACRO {ieeetc} {"IEEE Transactions on Computers"}

MACRO {ieeetcad}
 {"IEEE Transactions on Computer-Aided Design of Integrated Circuits"}

MACRO {ipl} {"Information Processing Letters"}

MACRO {jacm} {"Journal of the ACM"}

MACRO {jcss} {"Journal of Computer and System Sciences"}

MACRO {scp} {"Science of Computer Programming"}

MACRO {sicomp} {"SIAM Journal on Computing"}

MACRO {tocs} {"ACM Transactions on Computer Systems"}

MACRO {tods} {"ACM Transactions on Database Systems"}

MACRO {tog} {"ACM Transactions on Graphics"}

MACRO {toms} {"ACM Transactions on Mathematical Software"}

MACRO {toois} {"ACM Transactions on Office Information Systems"}

MACRO {toplas} {"ACM Transactions on Programming Languages and Systems"}

MACRO {tcs} {"Theoretical Computer Science"}




READ




FUNCTION {sortify}
{ purify$
  "l" change.case$
}

INTEGERS { len }

FUNCTION {chop.word}
{ 's :=
  'len :=
  s #1 len substring$ =
    { s len #1 + global.max$ substring$ }
    's
  if$
}









FUNCTION {sort.format.names}
{ 's :=
  #1 'nameptr :=
  ""
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }
    { nameptr #1 >
        { "   " * }
        'skip$
      if$

      s nameptr "{vv{ } }{ll{ }}{  ff{ }}{  jj{ }}" format.name$ 't :=

      nameptr numnames = t "others" = and
        { "et al" * }
        { t sortify * }
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
}


FUNCTION {sort.format.title}
{ 't :=
  "A " #2
    "An " #3
      "The " #4 t chop.word
    chop.word
  chop.word
  sortify
  #1 global.max$ substring$
}


FUNCTION {author.sort}
{ author empty.or.unknown
    { key empty.or.unknown
        { "to sort, need author or key in " cite$ * warning$
          ""
        }
        { key sortify }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {author.editor.sort}
{ author empty.or.unknown
    { editor empty.or.unknown
        { key empty.or.unknown
            { "to sort, need author, editor, or key in " cite$ * warning$
              ""
            }
            { key sortify }
          if$
        }
        { editor sort.format.names }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {author.organization.sort}
{ author empty.or.unknown
    { organization empty.or.unknown
        { key empty.or.unknown
            { "to sort, need author, organization, or key in " cite$ * warning$
              ""
            }
            { key sortify }
          if$
        }
        { "The " #4 organization chop.word sortify }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {editor.organization.sort}
{ editor empty.or.unknown
    { organization empty.or.unknown
        { key empty.or.unknown
            { "to sort, need editor, organization, or key in " cite$ * warning$
              ""
            }
            { key sortify }
          if$
        }
        { "The " #4 organization chop.word sortify }
      if$
    }
    { editor sort.format.names }
  if$
}


FUNCTION {presort}

{ type$ "book" =

  type$ "inbook" =
  or
    'author.editor.sort
    { type$ "proceedings" =
        'editor.organization.sort
        { type$ "manual" =
            'author.organization.sort
            'author.sort
          if$
        }
      if$
    }
  if$

  "    "
  *
  year field.or.null sortify
  *
  "    "
  *
  title field.or.null
  sort.format.title
  *
  #1 entry.max$ substring$
  'sort.key$ :=
}

ITERATE {presort}


SORT







STRINGS { longest.label }

INTEGERS { number.label longest.label.width }

FUNCTION {initialize.longest.label}
{ "" 'longest.label :=
  #1 'number.label :=
  #0 'longest.label.width :=
}

FUNCTION {longest.label.pass}
{ number.label int.to.str$ 'label :=
  number.label #1 + 'number.label :=
  label width$ longest.label.width >
    { label 'longest.label :=
      label width$ 'longest.label.width :=
    }
    'skip$
  if$
}

EXECUTE {initialize.longest.label}

ITERATE {longest.label.pass}




FUNCTION {begin.bib}

{ preamble$ empty.or.unknown

    'skip$
    { preamble$ write$ newline$ }
  if$
  "\begin{thebibliography}{"  longest.label  * "}" *                      write$ newline$
  "%%"                                                                    write$ newline$
  "%% You MUST have a \usepackage{x-bs} command in the document preamble" write$ newline$
  "%% in order to avoid undefined-macro errors in the bibliography."      write$ newline$
  "%%"                                                                    write$ newline$
  "\ifx \showADDRESS      \undefined \def \showADDRESS      #1{#1}          \fi" write$ newline$
  "\ifx \showARTICLENO    \undefined \def \showARTICLENO    #1{Article #1}  \fi" write$ newline$
  "\ifx \showAUTHOR       \undefined \def \showAUTHOR       #1{#1}          \fi" write$ newline$
  "\ifx \showAUTHORRAW    \undefined \def \showAUTHORRAW    #1{}            \fi" write$ newline$
  "\ifx \showBIBTYPE      \undefined \def \showBIBTYPE      #1#2{}          \fi" write$ newline$

  "\ifx \showBOOKPAGES    \undefined \def \showBOOKPAGES    #1{#1}          \fi" write$ newline$

  "\ifx \showBOOKTITLE    \undefined \def \showBOOKTITLE    #1{#1}          \fi" write$ newline$
  "\ifx \showCHAPTER      \undefined \def \showCHAPTER      #1{#1}          \fi" write$ newline$

  "\ifx \showCODEN        \undefined \def \showCODEN        #1{CODEN #1}    \fi" write$ newline$

  "\ifx \showCROSSREF     \undefined \def \showCROSSREF     #1{#1}          \fi" write$ newline$
  "\ifx \showDAY          \undefined \def \showDAY          #1{#1}          \fi" write$ newline$

  "\ifx \showDOI          \undefined \def \showDOI        { doi:\penalty 0} \fi" write$ newline$
  "\ifx \url              \undefined \input path.sty \let \url = \path      \fi" write$ newline$

  "\ifx \showEDITION      \undefined \def \showEDITION      #1{#1}          \fi" write$ newline$
  "\ifx \showEDITOR       \undefined \def \showEDITOR       #1{#1}          \fi" write$ newline$
  "\ifx \showEDITORRAW    \undefined \def \showEDITORRAW    #1{}            \fi" write$ newline$
  "\ifx \showHOWPUBLISHED \undefined \def \showHOWPUBLISHED #1{#1}          \fi" write$ newline$
  "\ifx \showINSTITUTION  \undefined \def \showINSTITUTION  #1{#1}          \fi" write$ newline$

  "\ifx \showISBN         \undefined \def \showISBN         #1{ISBN #1}     \fi" write$ newline$
  "\ifx \showISBNXIII     \undefined \def \showISBNXIII     #1{ISBN-13 #1}  \fi" write$ newline$


  "\ifx \showISSN         \undefined \def \showISSN         #1{ISSN #1}     \fi" write$ newline$


  "\ifx \showISSNL        \undefined \def \showISSNL        #1{ISSN-L #1}   \fi" write$ newline$

  "\ifx \showJOURNAL      \undefined \def \showJOURNAL      #1{#1}          \fi" write$ newline$
  "\ifx \showKEY          \undefined \def \showKEY          #1{#1}          \fi" write$ newline$

  "\ifx \showLCCN         \undefined \def \showLCCN         #1{LCCN #1}     \fi" write$ newline$

  "\ifx \showMONTH        \undefined \def \showMONTH        #1{#1}          \fi" write$ newline$
  "\ifx \showNOTE         \undefined \def \showNOTE         #1{#1}          \fi" write$ newline$
  "\ifx \showNUMBER       \undefined \def \showNUMBER       #1{#1}          \fi" write$ newline$
  "\ifx \showORGANIZATION \undefined \def \showORGANIZATION #1{#1}          \fi" write$ newline$
  "\ifx \showPAGECOUNTONE \undefined \def \showPAGECOUNTONE #1{, #1 page}   \fi" write$ newline$
  "\ifx \showPAGECOUNT    \undefined \def \showPAGECOUNT    #1{, #1 pages}  \fi" write$ newline$
  "\ifx \showPAGES        \undefined \def \showPAGES        #1{#1}          \fi" write$ newline$

  "\ifx \showPRICE        \undefined \def \showPRICE        #1{#1}          \fi" write$ newline$

  "\ifx \showPUBLISHER    \undefined \def \showPUBLISHER    #1{#1}          \fi" write$ newline$
  "\ifx \showSCHOOL       \undefined \def \showSCHOOL       #1{#1}          \fi" write$ newline$
  "\ifx \showSERIES       \undefined \def \showSERIES       #1{#1}          \fi" write$ newline$
  "\ifx \showTITLE        \undefined \def \showTITLE        #1{#1}          \fi" write$ newline$
  "\ifx \showTYPE         \undefined \def \showTYPE         #1{#1}          \fi" write$ newline$

  "\ifx \showURL          \undefined \def \showURL         {URL }           \fi" write$ newline$
  "\ifx \url              \undefined \input path.sty \let \url = \path      \fi" write$ newline$

  "\ifx \showVOLUME       \undefined \def \showVOLUME       #1{#1}          \fi" write$ newline$
  "\ifx \showYEAR         \undefined \def \showYEAR         #1{#1}          \fi" write$ newline$
}

EXECUTE {begin.bib}

EXECUTE {init.state.consts}


ITERATE {call.type$}


FUNCTION {end.bib}
{
  %% Complete the output .bbl file with a newline, end-of-bibliography
  %% command, and a final newline.
  %%
  %% At entry: stack = empty
  %% At exit:  stack = empty

  newline$
  "\end{thebibliography}" write$ newline$
}

EXECUTE {end.bib}
